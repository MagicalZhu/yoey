[TOC]

## 1.Redis的发布和订阅

- <font color=red>**发布订阅的的是什么?**</font>
  - <font color=red>进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</font>

- <font color=red>**Redis发布订阅的命令?**</font>

|                         **命令格式**                         |             **说明**             |
| :----------------------------------------------------------: | :------------------------------: |
| <font color=red>psubscribe [pattern1] [pattern2 ...]</font>  | 订阅一个或多个符合给定模式的频道 |
|  <font color=red>subscribe [channel1] [channel2...]</font>   |  订阅给定的一个或多个频道的信息  |
| <font color=red>punsubscribe [pattern1] [pattern2 ...]</font> |      退订所有给定模式的频道      |
| <font color=red>unsubscribe [channel1] [channel2...]</font>  |    指退订给定的一个或多个频道    |
|          <font color=red>publish channel msg</font>          |      将信息发送到指定的频道      |

### 1.1 Redsi发布订阅演示

**①. 订阅频道,同时接受到消息**

```shell
127.0.0.1:6379> SUBSCRIBE food imooc-java imooc-vue imooc
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "food"
3) (integer) 1
1) "subscribe"
2) "imooc-java"
3) (integer) 2
1) "subscribe"
2) "imooc-vue"
3) (integer) 3
1) "subscribe"
2) "imooc"
3) (integer) 4
# 接收到消息
1) "message"
2) "imooc-java"
3) "123"
```

**②. 通过publish 发送消息**

```sh
127.0.0.1:6379> publish imooc-java 123
(integer) 1
127.0.0.1:6379> 
```



## 2. Redis持久化机制

- Redis有以下的两种方式进行持久化
  - RDB (Redis DataBase)
  - AOF (Append Only File)
- <font color=red>**使用RDB还是AOF?**</font>
  1. 如果可以接受一段时间内的缓存丢失,就是使用RDB
  2. 如果对实时性的数据比较在意,就使用AOF
  3. <font color=red>也可以使用RDB和AOF一起做持久化,</font>
     - <font color=red>**RDB做冷备，可以在不同时期对不同版本做恢复，AOF做热备，保证数据仅仅只有1秒的损失**</font>
     - <font color=red>**Redis恢复会先加载AOF，如果AOF有问题会再加载RDB，这样就达到冷热备份的目的了**</font>

### 2.1 RDB

> RDB 的持久化方式适合大量数据的恢复,但是数据的完整性和一致性可能无法满足!

- <font color=red>**什么是RDB?**</font>

  - <font color=blue>Redis每隔一段时间，把内存中的数据写入磁盘的临时文件(快照)，恢复的时候把快照文件读进内存</font>
    - 如果宕机重启，那么内存里的数据肯定会没有的，那么再次启动redis后，则会恢复
  - 备份与恢复
    - 内存中进行备份 -> 备份到本地的磁盘文件
    - 本地的磁盘文件 -> 加载到内存中进行恢复

  - <font color=green>**Redis会Fork一个子进程来进行持久化 [ 子进程的数据和父进程一致 ]**</font> 
    - <font color=blue>子进程会将数据写入到一个临时文件,等持久化过程结束后,再将这个临时文件替换掉上次持久化好的件</font>
    - 过程中,主进程不需要进行任何的IO操作,保证的极高的性能

- <font color=red>**RDB的优点和缺点?**</font>
  - <font color=green>**优点:**</font> 
    1. 每隔一段的时间进行备份 <font color=red>**全量备份**</font>
    2. 灾备简单,可以实现远程传输 -> 拷贝RDB文件即可
    3. 子进程备份的时候,主进程不会有任何的IO操作,保证数据的完整性
    4. 相对AOF来说,当有大文件的时候,RDB可以快速的重启恢复
  - <font color=green>**缺点:**</font> 
    1. 发生故障时,最后一次的备份数据有可能会丢失
    2. 子进程所占用的内存比会和父进程一模一样，如会造成CPU负担
    3. 由于定时**全量备份**是重量级操作,所以对于实时备份,就无法处理了
- <font color=red>**如何恢复Redis的备份数据?**</font>
  - 只需要将 RDB文件放在 Redis的工作目录即可!
- <font color=red>**触发RDB 备份的方式?**</font>
  1. <font color=blue>通过命令手动备份</font>
  2. <font color=blue>通过配置文件中的快照配置</font>

#### 2.1.1  RDB的备份 -> 手动备份 [Save | Bgsave]

- `Save` -> <font color=blue>由主进程进行快照操作，会阻塞住其他请求</font>
- `BgSave` -> <font color=blue>Redis 会fork一个子进程进行快照操作,此时主进程还可以处理外部客户端的请求</font>

#### 2.1.2  RDB的备份 -> 自动备份 [Redis RDB相关的配置信息]

- <font color=red>RDB 文件默认保存为 dump.rdb</font>
- <font color=red>**保存机制**</font>
  - `save <time> <changes>` -> <font color=blue>指定的时间(time)内,指定个数(changes)的键发生变化,就会备份</font>
    - 比如
      - `save 900 1` => 900秒内有至少1个键被更改则进行快照
      - `save 300 10` => 300秒内有至少10个键被更改则进行快照
    - 这些配置信息,只要有一个满足,就会备份
  - `stop-writes-on-bgsave-error`
    - 如果save的过程中出错,是否停止写操作,
    - 可选值 `yes|no`
  - `rdbcompression`
    - 是否开启RDB压缩模式
    - 可选值 `yes|no`
  - `rdbchecksum`
    - 是否使用CRC64算法校验对rdb进行数据校验
    - 可选值 `yes|no`

### 2.2 AOF

- <font color=red>**AOF的特点**</font>
  1. <font color=red>以日志的形式来记录用户的请求。读记录不会记录,只有写记录才会被存储</font>
  2. <font color=red>文件追加的方式,而不是修改覆盖</font>
  3. redis 的aof恢复其实就是追加的日志文件,从头到尾读取并执行写操作
- <font color=red>**AOF的优点和缺点?**</font>
  - <font color=green>**优点:**</font> 
    1. AOF更加耐用, 可以以秒级别为单位备份，如果发生问题，也只会丢失最后一秒的数据，大大增加了可靠性和数据完整性
       - 所以AOF可以每秒备份一次，使用fsync操作
    2. 以log日志的形式追加,如果磁盘满了,会执行 `redis-check-aof` 命令
    3. 当数据太大的时候，redis可以在后台自动重写aof
       - 当redis继续把日志追加到老的文件中去时，重写也是非常安全的，不会影响客户端的读写操作
    4. AOF日志包含所有的写操作,会更加便于redis的恢复
  - <font color=green>**缺点:**</font> 
    1. 相同的数据,同一份数据,AOF一般会比RDB文件大
    2. 针对不同的同步机制,AOF会比RDB慢
       - 因为为AOF每秒都会备份做写操作，这样相对与RDB来说就略低
       - 每秒备份fsync没毛病，但是如果客户端的每次写入就做一次备份fsync的话，那么redis的性能就会下降
- <font color=red>**Redis 配置中AOF相关**</font>
  - `appendonly`
    - 是否开启AOF,可选值 `yes|no`
    - 默认关闭(no)
  - `appendfilename`
    - aof的文件名
  - `appendfsync`
    - 同步的方式,可选值 `no|everysec|always`
      - `no` => 不同步
      - `everysec` => 每秒备份 √
      - `always` => 每次操作都会备份,安全并且数据完整,但是慢,性能差
  - `auto-aof-rewrite-percentage 100`
  - `auto-aof-rewrite-min-size 64mb`



## 3. Redis主从架构 [读写分离]

### 3.1 主从复制原理

- <font color=red>**主从复制的同步策略**</font>
  - 主从刚刚连接的时候 => 使用全量同步
  - 全同步结束后 => 进行增量同步
- <font color=red>**全量同步 ->> 一般在slave初始化阶段,需要同步master上的数据**</font>
  1. slave 连接 master,发送SYNC 命令
  2. master 接收到SYNC 命令后,开始执行 BGSAVE命令生成RDB文件,同时使用缓存区记录期间所有的写命令
  3. master 备份完毕后,向所有的slave 发送RDB快照文件,并且继续向缓冲区记录的客户端的写命令
  4. slave 接收到快照文件后,删除所有的旧数据,同时载入接收到的快照
  5. salve 接收完快照文件后, master 继续向slave发送 缓冲区中的写命令
  6. slave 接收并且执行缓冲区的写命令
  7. 最后slave完成了初始化,达到数据与master 的一致,并且接收客户端的读请求
- <font color=red>**增量同步 -> master所有的写操作都同步到slave的过程**</font>
- <font color=red>**注意点 : 主从复制时,应该开启持久化**</font>
  - 如果关闭持久化,当master宕机后,磁盘中不会有备份文件,当master重启后,此时进行全同步的话,会将slave中的数据清空!

![image-20201006142134308](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142134308.png)

#### 3.1.1 "一主二从"

- "一主二从"是一种常见的主从架构
- <font color=red>**如何配置"一主二从"模式**</font>
  - slaveA 和 slaveB 的redis配置文件中,配置以下信息
    - `replicaof <masterip> <masterport>` => 设置master的ip 以及端口
    - ` masterauth <master-password>` => 如果master设置了密码,配置认证密码
    - `replica-read-only yes` => 设置slava 是否是只读的,默认是yes
  - 通过 `info replication` 命令,查看主从信息

**①. 配置信息**

```she
replicaof 192.168.0.5 6379
masterauth 123
replica-serve-stale-data yes
replica-read-only yes
```

**②. info replication**

```sh
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.0.97,port=6379,state=online,offset=11099,lag=1
slave1:ip=192.168.0.232,port=6379,state=online,offset=11099,lag=1
master_replid:0b9d9a2f8cb219dfe5a3aef89757f37a8c40da8c
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:11099
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:11099
```



#### 3.1.2 "无磁盘化复制"

- 无磁盘化复制 : <font color=red>子进程直接将RDB文件通过网络发送给slave,而不需要将磁盘作为中间的存储源</font>

![image-20201006142144952](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142144952.png)

### 3.2 Redis 缓存过期以及内存淘汰机制

> 由于计算机的内存有限,而Redis的高并发都来自于内存!

- <font color=red>**已过期的Key改如何处理?**</font>

  - **设置了`expire` 的key缓存过期了,但是服务器的内存还是会被继续占用**,这是由Redis基于下面两种删除策略决定的
    - <font color=red>定时删除 [主动]</font>
      - <font color=blue>定时随机的检查过期的key,如果过期了就会被清理删除 [ 每秒检查次数在redis.conf中的hz配置 ]</font>
  
    - <font color=red>惰性删除 [被动]</font>
      - <font color=blue>当客户端请求一个已经过期的key的时候，那么redis会检查这个key是否过期，如果过期了，则删除，然后返回一个nil。这种策略对cpu比较友好，不会有太多的损耗，但是内存占用会比较高</font>

- <font color=red>**Redis的内存淘汰机制 (memory management)?**</font>

  - ==当内存满了之后,Redis提供了一套缓存淘汰策略==
    - `maxmemory` => 当内存到达使用率,开始清理缓存
    - `maxmemory-policy <policy>` => 设置淘汰策略
      - `noeviction` (不推荐)
        - **旧缓存永不过期，新缓存设置不了，返回错误**
      - `allkeys-lru`
        - **清除最少用的旧缓存，然后保存新的缓存（推荐使用）**
      - ~~`allkeys random`~~
        - **在所有的缓存中随机删除（不推荐）**
      - `volatile-lru`
        - **在那些设置了expire过期时间的缓存中，清除最少用的旧缓存，然后保存新的缓存**
      - `volatile-random`
        - **在那些设置了expire过期时间的缓存中，随机删除缓存**
      - `volatile-ttl`
        - **在那些设置了expire过期时间的缓存中，删除即将过期的**

### 3.3 哨兵机制(sentinel) -> 实现Redis的高可用[故障转移]

> 在主从复制的情景下,当master挂了之后,如何保证集群的可用性

- <font color=red>**什么是哨兵(sentinel) ?**</font>
  - <font color=red>哨兵是用于监控Redis集群中Master状态的单独的进程，是 Redis 高可用解决方案</font>
  - <font color=red>哨兵可以监视一个或者多个redis master服务，以及这些master服务的所有从服务</font>
    - 当某个master服务宕机后，会把这个master下的某个从服务升级为master来替代已宕机的master继续工作
    - 当原来master恢复后,会变成这个选举后的master的子节点
- <font color=red>**哨兵的功能**</font>
  1. <font color=blue>**监控** ->  哨兵会不断地定期检查master和slave是否运作正常</font>
  2. <font color=blue>**提醒** -> 当被监控的某个Redis 服务器出现问题时，哨兵可以发送通知</font>
  3. <font color=blue>**自动故障迁移**</font>
     - 当Master不可用时,哨兵会开始自动故障迁移操作
       - 将一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器
       - 当客户端试图连接失效的主服务器时，<font color=red>**集群也会向客户端返回新主服务器的地址**</font>,使得集群可以使用新主服务器代替失效服务器
- <font color=red>**常见的术语**</font>
  - <font color=blue>**主观下线(Subjectively Down =>SDOWN)**</font>
    - 指的是单个 Sentinel 实例无法ping通redis服务器,从而做出的下线判断
  - <font color=blue>**客观下线(Objectively Down =>ODOWN)**</font>
    - 指的是多个 Sentinel 实例无法ping通redis服务器,并且多个sentinel一致认为redis服务器已经主观下线后的判断
    - <font color=red>**客观下线仅限于Master服务器**,slave节点是否下线不需要多个sentinel进行协商</font>
- <font color=red>**哨兵需要执行的任务**</font>
  - 每个 Sentinel以==每秒一次==的频率向它所知的master、slave以及其他 Sentinel 实例发送一个 ping 命令
    - 如果一个redis 回复ping命令超时，那么这个实例会被 Sentinel 标记为主观下线
    - <font color=red>如果一个 Master被标记为主观下线, 那么正在监视这个master的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态</font>
    - <font color=red>如果一个master 被标记为主观下线,并且有足够数量的 Sentinel在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线</font>
- <font color=red>**如何配置哨兵 ?**</font>
  1. <font color=red>**创建并且配置 sentinel.conf**</font>
     - <font color=red>普通配置信息</font>
       - `port` -> 哨兵的端口
       - `pidfile` -> 进程文件路径
       - `dir` -> 哨兵的工作目录
       - `daemonize ` -> 哨兵是否以后台进程的方式运行
       - `protected-mode ` -> 是否开启保护模式
       - `logfile` -> 日志文件路径
     - <font color=red>核心配置信息</font>
       - ` sentinel monitor <master-name> <ip> <redis-port> <quorum> `
         - master-name : 主服务器的别名
         - ip: master的ip
         - redis-port : master 的端口
         - <font color=blue>quorum -> 当指定个数的哨兵与master无法连接,就认为master宕机,开始进行故障转移</font>
           - <font color=red>如果认为master主观下线的Sentinel的数量不达标，就不会执行自动故障迁移</font>
           - **一般为 奇数**
       - `sentinel auth-pass <master-name> <password>`
         - master-name : 主服务器的别名
         - password: master的认证密码
       - `sentinel down-after-milliseconds <master-name> <time>`
         - <font color=blue>time -> **master被sentinel认定为失效的间隔时间,以毫秒为单位**</font>
         - <font color=red>**如果redis在给定的时间内,没有回复sentinel的ping命令,或者返回错误,那么sentinel就认为redis服务器 主观下线 (SDOWN)**</font>
         - 默认 30000 -> 30秒
       - `sentinel parallel-syncs  <master-name> <num>`
         - master-name : 主服务器的别名
         - <font color=blue>num-> 故障转移后,同一时间与新的master进行数据同步的slave的数量</font>
       - ` sentinel failover-timeout <master-name> <time>` 
         - master-name : 主服务器的别名
         - <font color=red>主备切换的超时时间(毫秒为单位), 默认是 **180000**</font>
         - 哨兵要去做故障转移，哨兵也是一个进程，如果他没有去执行，超过这个时间后，会由其他的哨兵来处理
  2. 启动哨兵 -> `redis-sentinel sentinel.conf`

![image-20201006142155029](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142155029.png)

#### 3.3.1 哨兵模式的实现

**①. 配置sentinel.conf**

```shell
#Baisc
protected-mode no
port 26379
daemonize yes
pidfile "/var/run/redis-sentinel.pid"
logfile "/usr/local/redis/sentinel/redis-sentinel.log"
dir "/usr/local/redis/sentinel"

#Core
sentinel monitor redis-master 192.168.0.5 6379 2
sentinel auth-pass redis-master 123
sentinel down-after-milliseconds redis-master 10000
```

**②. 启动哨兵,查看日志**

- 会展示master 和slave哨兵的唯一ID => Sentinel ID

```shell
* Increased maximum number of open files to 10032 (it was originally set to 1024).
* Running mode=sentinel, port=26379.
# Sentinel ID is 6055f0e8275a1761fe7ee08eccde4c35c6a5ef9d
# +monitor master redis-master 192.168.0.5 6379 quorum 2
* +slave slave 192.168.0.97:6379 192.168.0.97 6379 @ redis-master 192.168.0.5 6379
* +slave slave 192.168.0.232:6379 192.168.0.232 6379 @ redis-master 192.168.0.5 6379
* +sentinel sentinel 2c8afff5a659f77c2b6cae1709420d289de623ad 192.168.0.97 26379 @ redis-master 192.168.0.5 6379
* +sentinel sentinel d34dccd1955a04e750f4a94ca963879da9e018e1 192.168.0.232 26379 @ redis-master 192.168.0.5 6379
```

**③. 启动哨兵,查看之前的配置文件 sentinel.conf**

- 新增以下的配置信息

```shell
# Generated by CONFIG REWRITE
sentinel config-epoch redis-master 0
sentinel leader-epoch redis-master 0
sentinel known-replica redis-master 192.168.0.97 6379
sentinel known-replica redis-master 192.168.0.232 6379
sentinel known-sentinel redis-master 192.168.0.5 26379 6055f0e8275a1761fe7ee08eccde4c35c6a5ef9d
sentinel known-sentinel redis-master 192.168.0.97 26379 2c8afff5a659f77c2b6cae1709420d289de623ad
sentinel current-epoch 0
```

**④. 停止master节点,查看日志信息**

- 可以看到,当哨兵认为 master宕机后,会进行 "故障转移",并且选举一个新的master

![image-20201006142206165](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142206165.png)

**⑤. 新的master上,info replication**

```sh
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=192.168.0.97,port=6379,state=online,offset=257432,lag=1
master_replid:70e558c79628a6ebc1d7d3d9d57a12434a0c2d1c
master_replid2:0b9d9a2f8cb219dfe5a3aef89757f37a8c40da8c
master_repl_offset:257721
second_repl_offset:174914
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:57
repl_backlog_histlen:257665
```



#### 3.3.2 哨兵信息查看

- <font color=red>**操作步骤**</font>	
  1. 通过 `redis-cli -p 哨兵的端口` 进入哨兵的客户端
  2. 输入 命令查看
     - `sentinel master <master-name>`
       - **查看指定master下的master节点信息**
     - `sentinel slaves <master-name>`
       - **查看指定master下的slave节点信息**
     - `sentinel sentinels <master-name>`
       - **查看指定master下的哨兵节点信息**

#### 3.3.3 SpringBoot集成哨兵

- <font color=red>**操作步骤?**</font>

  - 修改`application.yml`中Redis相关的配置文件

    - 移除 `host`和 `port` 配置 -> 有多台redis 配置,并且master节点不固定
    - 配置 `sentinel`节点 -> master信息由哨兵返回
      - `master` : 主服务器的名称
      - `nodes`  : 哨兵的节点信息(ip+端口) -> 多个哨兵信息用逗号分隔 

    ```yml
      redis:
        database: 1
        password: 123
        sentinel:
          master: redis-master
          nodes: 192.168.0.5:26379,192.168.0.97:26379,192.168.0.232:26379
    ```

#### 3.3.4 哨兵模式/集群的"脑裂"

- <font color=red>步骤说明</font>

  1. Master 节点 M1 和两个Slave节点 S2,S3在不同的网络分区

  2. 由于网络原因,M1被标记为客观下线,同时sentinel会在S2 和 S2 中选举一个新的master节点,比如说S2 被选举为 M2
  3. 此时处于M1 网络分区的客户端是依旧可以访问 M1 的,并对M1 进行了数据操作
  4. 当网络恢复后,M1 会变成 M2 的 的Slave节点,并且进行主从同步
     - <font color=red>**这样,之前M1中写入的数据就会被丢弃!**</font>

- <font color=red>如何避免?</font>

  - 修改Redis 配置文件,<font color=red>如果master检测到不再能够将其写入转移到指定数量的副本，就停止接受客户端写入</font>

    ```shell
    #  表示连接到 master 的最少slave数量
    min-replicas-to-write 3 
    #  表示 slave 连接到 master 的最大延迟时间
    min-replicas-max-lag 10        
    ```

    

## 4. Redis集群 [Redis-Cluster]

- **为什么需要有Redis集群?**
  - <font color=red>**单个master-slave模式的缺点?**</font>
    	1. <font color=blue>单个Master的容量有限,数据到达一定程度会有瓶颈</font>
     2. <font color=blue>master同步数据(异步的复制)时宕机了,就会导致slave上的数据不是最新的,当这个master重新连接变成slave后,由于会全量同步新的master的数据,就导致了数据的丢失!</font>
  - 虽然<font color=red>**主从复制+哨兵模式 也是一种集群,可以提高读并发**</font>,但是由于单个master-slave节点的缺点,此时可以水平拓展,通过<font color=red>**Redis集群(Redis-Cluster)来支撑多个 master-slave,支持海量的数据,实现高可用以及高并发**</font>
- **集群容错?**
  - 构建Redis集群,至少需要 `3`个节点作为master,同时每一个master有一个slave => `三主三从`
- **Redis Cluster的端口**
  - 在Redis集群的架构下，每个 redis 要放开两个端口号 [<font color=red>6379 和 16379</font>]
    - 16379 端口号是用来进行节点间通信的，也就是Cluster Bus,用来进行故障检测、配置更新、故障转移授权
- <font color=red>**Redis集群 的特点?**</font>
  1. 集群中每个节点都知道彼此之间的关系,也会知道自己的角色,同样也知道自己存在于一个集群环境中
     - <font color=blue>**集群中节点之间可以相互的通信**</font>
     - <font color=blue>**集群中节点之间的关系会保存到配置文件中**</font>
  2. <font color=blue>客户端要和集群建立连接的话,只需要和其中一个建立关系即可</font>
  3. 节点宕机后,也会像哨兵模式一样,通过选举的方式进行切换/故障转移
  4. Redis中有很多Slot(插槽),也可以称之为槽节点,用于存储数据 

![image-20201006142216781](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142216781.png)



### 4.0 集群环境下的通讯方式

- 主要分为两种
  - <font color=red>集中式</font>
    - <font color=red>将集群元数据（节点信息、故障等等）几种存储在某个节点上</font> 
  - <font color=red>gossip协议</font>
    - <font color=red>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更</font>
    - <font color=blue>**Redis 就是采用的gossip方式**</font>

#### 4.0.1 集中式的优缺点?

- **优点**:
  - 元数据的读取和更新，时效性非常好,一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到
- **缺点**
  - 所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力

#### 4.0.2 gossip 协议

- **Gossip协议的特性?**
  
  - <font color=red>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000</font>
    
    - 比如6379，那么用于节点间通信的就是 16379端口
    - 每个节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其它几个节点接收到 ping 之后返回 pong
    
  - <font color=red>gossip 协议包含多种消息，包含 ping、pong、meet、fail 等等</font>
  
    - `meet`
  
      - <font color=red>某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信</font>
      - Redis集群添加节点,内部就是发送了一个Gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。
  
    - `ping`
  
      - 每个节点都会给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。
  
    - `pong`：返回ping和meeet，包括自己的状态和其他信息，也用于信息广播和更新。
  
    - `fail`：某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点说，某个节点宕机啦。
  
      
  
- **优点**:
  
  - 元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力
  
- **缺点**

  - 元数据的更新有延时，可能导致集群中的一些操作会有一些滞后

### 4.1 搭建Redis集群

- <font color=red>**操作步骤**</font>

  1. <font color=red>**配置Redis 的配置文件**</font>
     - <font color=red>`cluster-enabled yes`</font>
       - **是否开启集群模式**
       - 可选值 yes|no
     -  <font color=red>`cluster-config-file node-xxx.conf`</font>
       - 指定节点的配置文件 -> **不需要手动创建,由redis自己维护**
       - <font color=red>每一个节点需要有一个配置文件(包括主从节点)</font>
         - <font color=blue>每个节点处于集群的角色都需要告知其他所有节点，这个文件用于存储集群模式下的集群状态等信息</font>
         - <font color=blue>如果你要重新创建集群，那么把这个文件删了就行</font>
     - <font color=red>`cluster-node-timeout 5000`</font>
       - 超时时间，超时则认为master宕机，随后主备切换
       - 默认 `15000 ms`
     - <font color=red>`appendonly yes`</font>
       - 是否开启AOF
       - 可选值 yes|no
2. <font color=red>**创建集群**</font>
     -  <font color=red>`redis-cli -a 指定认证密码 --cluster create ip1:port1 ...  ipN:portN --cluster-replicas 1`</font>
       - **`--cluster-replicas` -> 主节点和从节点比例为1**
         - 如果有6 个 => 1~3 为主, 4~6为从
           - 比如： 1和4，2和5，3和6分别对应为主从关系
       - `slots`
         - ==槽，用于装数据 ->主节点有，从节点没有==
  3. <font color=red>**检查集群信息**</font>
     -  <font color=red>`redis-cli --cluster check nodeIP:nodePort`</font>
  4. <font color=red>**进入集群客户端**</font>
     - <font color=red>`redis-cli -a 密码 -c -h host -p port`</font>
  5. <font color=red>**注意**</font>
     - **构建集群的时候,需要把redis的持久化文件删除,再去构建**
     - <font color=red>**Redis的集群模式下,没有16个库的概念,所有的数据都存储在Slot槽中!!!**</font>

**①. 修改配置的相关信息 -> 配置多个节点**

```shell
################################ REDIS CLUSTER  ###############################
cluster-enabled yes
cluster-config-file nodes-97.conf
cluster-node-timeout 5000

appendonly yes
```

**②. 创建集群**

```shell
[root@localhost working]# redis-cli -a 123 --cluster create 192.168.0.5:6379 192.168.0.97:6379 192.168.0.232:6379 192.168.0.223:6379 192.168.0.6:6379 192.168.0.185:6379 --cluster-replicas 1
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 192.168.0.6:6379 to 192.168.0.5:6379
Adding replica 192.168.0.185:6379 to 192.168.0.97:6379
Adding replica 192.168.0.223:6379 to 192.168.0.232:6379
M: d3686f65caf1a7e5dd36a179f20e0e0498e15fee 192.168.0.5:6379
   slots:[0-5460] (5461 slots) master
M: 829973be3bcf12fd303c17f89c1d60c4fef1d315 192.168.0.97:6379
   slots:[5461-10922] (5462 slots) master
M: 8cb0407d41323801e59282c1170ba392ab74e9d5 192.168.0.232:6379
   slots:[10923-16383] (5461 slots) master
S: f4e00922e3d4630ec75a68deec438638df3f9a41 192.168.0.223:6379
   replicates 8cb0407d41323801e59282c1170ba392ab74e9d5
S: 9fb4acffafabcbb26d5d99282abf3b85d900c482 192.168.0.6:6379
   replicates d3686f65caf1a7e5dd36a179f20e0e0498e15fee
S: 32cef3e5de497c29e1a0c930813cb72a948be536 192.168.0.185:6379
   replicates 829973be3bcf12fd303c17f89c1d60c4fef1d315
....
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

**③.检查集群信息**

```shell
[root@localhost working]# redis-cli -a 123 --cluster check 192.168.0.5:6379
192.168.0.5:6379 (d3686f65...) -> 0 keys | 5461 slots | 1 slaves.
192.168.0.232:6379 (8cb0407d...) -> 0 keys | 5461 slots | 1 slaves.
192.168.0.97:6379 (829973be...) -> 0 keys | 5462 slots | 1 slaves.
[OK] 0 keys in 3 masters.
0.00 keys per slot on average.
>>> Performing Cluster Check (using node 192.168.0.5:6379)
M: d3686f65caf1a7e5dd36a179f20e0e0498e15fee 192.168.0.5:6379
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
S: 9fb4acffafabcbb26d5d99282abf3b85d900c482 192.168.0.6:6379
   slots: (0 slots) slave
   replicates d3686f65caf1a7e5dd36a179f20e0e0498e15fee
S: f4e00922e3d4630ec75a68deec438638df3f9a41 192.168.0.223:6379
   slots: (0 slots) slave
   replicates 8cb0407d41323801e59282c1170ba392ab74e9d5
M: 8cb0407d41323801e59282c1170ba392ab74e9d5 192.168.0.232:6379
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: 32cef3e5de497c29e1a0c930813cb72a948be536 192.168.0.185:6379
   slots: (0 slots) slave
   replicates 829973be3bcf12fd303c17f89c1d60c4fef1d315
M: 829973be3bcf12fd303c17f89c1d60c4fef1d315 192.168.0.97:6379
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```



**④. 通过集群客户端操作集群**

- 通过redis-cli 进入客户端
- 在集群模式下,无法使用select N 的方式切换数据库
- 设置的key 会通过 "一致性hash算法" 的方式,存在不同的slot上

```sh
[root@localhost ~]# redis-cli -a 123 -c -h 192.168.0.6 -p 6379
192.168.0.6:6379> set name yoey
-> Redirected to slot [5798] located at 192.168.0.97:6379
OK
# 无法使用 select N 切换数据库
192.168.0.97:6379> select 1
(error) ERR SELECT is not allowed in cluster mode
192.168.0.97:6379> keys *
1) "name"
192.168.0.97:6379> set age 22
-> Redirected to slot [741] located at 192.168.0.185:6379
OK
192.168.0.185:6379> get name
-> Redirected to slot [5798] located at 192.168.0.97:6379
"yoey"
```

### 4.2 Slot 槽节点

- <font color=red>**Slot总数: 16384**</font>

- <font color=red>**槽Slot如何存储**</font>

  - <font color=red>hash(key)%16384 => 将key进行hash后再和槽总数(16384)取模,得到的就是这个数据存储在哪个槽中</font>

**槽slot分配**

![image-20201006142228187](image/3.Redis%E8%BF%9B%E9%98%B6/image-20201006142228187.png)



### 4.3 SpringBoot整合Redis集群

- <font color=red>**操作步骤**</font>
  - 修改`application.yml`中Redis相关的配置文件
    - 移除 `host`, `port`, `database` 配置 -> 因为集群中master不固定,且没有16个数据库的概念
    - 配置 `cluster`节点 -> master信息由集群返回
      - `nodes`  : 集群的节点信息(ip+端口) -> 多个节点信息用逗号分隔 
- <font color=red>**注意: SpringBoot中使用RedisTemplate操作时,如果集群中的一个节点宕机后,无法识别切换后的Slave**</font>
  - ==可以通过Jedis/Redisson等第三方Redis客户端访问Redis==

```yml
# Redis 集群模式
  redis:
    password: 123
    cluster:
      nodes: 192.168.0.5:6379,192.168.0.6:6379,192.168.0.185:6379,192.168.0.97:6379,192.168.0.223:6379,192.168.0.232:6379
```

#### 4.3.1 使用Jedis整合集群

- <font color=red>**操作步骤**</font>
  1. application.yml中配置Jedis的集群属性信息
     - `clusterNodes` -> 多个集群几点
     - `password`
     - `connectionTimeOut` -> 连接超时时间
     - `soTime` -> 返回值的超时时间
     - `maxAttempts` -> 最大重试次数
  2. 添加配置类,向容器中注入 `JedisCluster`对象
  3. 使用 JedisCluster 操作Redis

**①. 配置application.yml**

```yml
redis:
  clusterNodes: 192.168.0.5:6379,192.168.0.6:6379,192.168.0.185:6379,192.168.0.97:6379,192.168.0.223:6379,192.168.0.232:6379
  password: 123             # 密码
  connectionTimeout: 6000   # 连接超时时间
  soTimeout: 5000           # 返回值的超时时间
  maxAttempts: 10           # 出现异常最大重试次数
```

**②. 通过配置类注入**

```java
@Configuration
public class RedisAutoConfiguration {
    @Value("#{'${redis.clusterNodes}'.split(',')}")
    private List<String> clusterIpPortList;

    @Value("${redis.connectionTimeout}")
    private int connectionTimeout;

    @Value("${redis.soTimeout}")
    private int soTimeout;

    @Value("${redis.maxAttempts}")
    private int maxAttempts;

    @Value("${redis.password}")
    private String password;

    @Bean
    public JedisCluster jedisCluster() {
        Set<HostAndPort> nodes = new HashSet<>();
        for (String node : clusterIpPortList){
            String [] ipPortStr = node.split(":");
            nodes.add(new HostAndPort(ipPortStr[0].trim(), Integer.valueOf(ipPortStr[1].trim())));
        }
        JedisCluster jedisCluster = new JedisCluster(nodes, connectionTimeout, soTimeout, maxAttempts,password , new GenericObjectPoolConfig());
        return jedisCluster;
    }
}
```

**③.测试使用**

```java
@Autowired
private JedisCluster jedisCluster

@RequestMapping(value="/get")
public String get(String key){
    return jedisCluster.get(key);
}
```

