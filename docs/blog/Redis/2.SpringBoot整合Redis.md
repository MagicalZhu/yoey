[TOC]

## 1.Redis线程模型

### 1.1 同步阻塞,同步非阻塞,异步阻塞,异步非阻塞

- <font color=red>**同步和异步相对于客户端来说, 阻塞与非阻塞相对于服务端来说!!**</font>
  - ==同步==: 需要客户端每隔一段时间,以轮询的方式去查看有没有响应
  - ==异步==: 由服务端主动告知客户端有没有响应
  - ==阻塞==: 服务端在处理任务过程中,不处理新的客户端请求
  - ==非阻塞==: 服务端在处理任务过程中,可以处理新的客户端请求

- <font color=red>**同步阻塞**</font>
  - 客户端发送请求给服务端，请求需要处理很长时间
    - 客户端一直等待服务端的响应,不做其他任何事
    - 服务端也不会接受其他客户端的请求
  - <font color=green>通信机制比较简单粗暴，但是效率低下</font>
- <font color=red>**同步非阻塞**</font>
  - 客户端发送请求给服务端，请求需要处理很长时间
    - 客户端一直等待服务端的响应,不做其他任何事
    - 服务端可以处理其他的请求,过一会回来处理原先的
  - <font color=green>这种方式很高效，一个服务端可以处理很多请求，不会在因为任务没有处理完而堵着，所以这是非阻塞的</font>

- <font color=red>**异步阻塞**</font>
  - 客户端发送请求给服务端，请求需要处理很长时间
    - 客户端不会等待服务器响应，可以做其他的任务,等服务器处理完毕后再把结果响应给客户端，客户端得到回调后再处理服务端的响应
    - 期间服务器不会接受其他客户端的请求
  - <font color=green>这种方式可以避免客户端一直处于等待的状态，优化了用户体验，其实就是类似于网页里发起的ajax异步请求</font>
- <font color=red>**异步非阻塞**</font>
  - 客户端发送请求给服务端，请求需要处理很长时间
    - 客户端是异步的,请求期间可以做其他的任务，可以在回调函数里处理服务端响应
    - 服务端是非阻塞的，所以服务端可以去处理其他的任务

### 1.1 Redis线程模型

- ==Redis是单线程的==,但是采用的是io多路复用模式（也就是非阻塞方式）
  - 在接收到用户请求后，多路复用器发送到文件事件分配器的速度就会很快(不需要等待上一个请求获得回复即可处理下一个请求）
  - 又由于是单线程模型，所以避免了上下文切换带来的损耗
  - 另外在文件事件分配器这个地方，进行的是纯内存操作，因此速度会非常快
- 线程模型
  1. 通过连接应答处理器 处理客户端的连接请求
  2. 客户端发送 set等请求时,是一个 `AE_Readable` 事件,通过 命令请求处理器进行处理
  3. 客户端需要读取数据时,会发送一个 Write请求,通过`AE_Writeable` 事件处理

![image-20201006142109500](image/2.SpringBoot%E6%95%B4%E5%90%88Redis/image-20201006142109500.png)



## 2. SpringBoot整合Redis

### 2.1 通过SpringBoot操作Redis

- <font color=red>**操作步骤**</font>
  1. 引入Redis 的SpringBoot Starter -> `spring-boot-starter-data-redis`
  2. yml中对Redis属性进行配置
  3. 引入 Bean `RedisTemplate`,操作Redis

<font color=red color=red>**①. Maven引入starter**</font>

```xml
<!--添加redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

<font color=red color=red>**②. 配置Redis连接**</font>

```yml
####################
#  Redis配置信息
####################
  redis:
    host: 192.168.0.5
    password: 123
    database: 1
    port: 6379
```

<font color=red color=red>**③. 通过StringRedisTemplate 操作redis**</font>

```java
@Component
public class RedisUtils {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    // key的基本操作
    public long ttl(String key){
        return stringRedisTemplate.getExpire(key);
    }
    public void expire(String key,Long timeOut){
        stringRedisTemplate.expire(key,timeOut, TimeUnit.SECONDS);
    }
    public long incr(String key,Long step){
        return stringRedisTemplate.opsForValue().increment(key,step);
    }
    public Set<String> keys(String pattern){
        return stringRedisTemplate.keys(pattern);
    }
    public void del(String key){
        stringRedisTemplate.delete(key);
    }

    // String操作
    public void set(String key,String value){
        stringRedisTemplate.opsForValue().set(key,value);
    }
    public void set(String key,String value,Long timeout){
        stringRedisTemplate.opsForValue().set(key,value,timeout,TimeUnit.SECONDS);
    }
    public String get(String key){
        return (String)stringRedisTemplate.opsForValue().get(key);
    }
    public List<String> mget(List<String> keys){
        return stringRedisTemplate.opsForValue().multiGet(keys);
    }

    /**
     * 批量查询key的值 ->pipeline
     * @param keys
     * @return
     */
    public List<Object> batchGet(List<String> keys){
        List<Object> result = stringRedisTemplate.executePipelined(new RedisCallback<String>() {
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException {
                StringRedisConnection con = (StringRedisConnection) connection;
                for (String key : keys) {
                    con.get(key);
                }
                return null;
            }
        });
        return result;
    }

    // Hash表
    public void hset(String key,String property,String value){
        stringRedisTemplate.opsForHash().put(key,property,value);
    }
    public String hget(String key,String property){
        return (String)stringRedisTemplate.opsForHash().get(key,property);
    }
    public void hdel(String key,Object ...property){
        stringRedisTemplate.opsForHash().delete(key,property);
    }
    public Map<Object,Object> getAll(String key){
        return stringRedisTemplate.opsForHash().entries(key);
    }

    //List
    public void lpush(String key,String value){
        stringRedisTemplate.opsForList().leftPush(key,value);
    }
    public void rpush(String key,String value){
        stringRedisTemplate.opsForList().rightPush(key,value);
    }
    public String lpop(String key){
        return stringRedisTemplate.opsForList().leftPop(key);
    }
}
```



## 3. 业务代码优化

### 3.1 优化轮播图以及商品分类

- 将轮播图以及商品信息相关数据写入Redis
- <font color=red>何时更新轮播图的Redis信息?</font>
  1. 通过后台运营系统,当轮播图信息发生改变,就去删除缓存
  2. 通过定时任务去定时重置

<font color=red color=red>**优化 com.imooc.controller.IndexControlle**</font>r

```java
@ApiOperation("获取所有的轮播图数据")
@GetMapping("/carousel")
public ResponseResult carousel(){

    String carouselJson = redisUtils.get("carousel");
    List<Carousel> carousels = new ArrayList<>();
    if(StringUtils.isBlank(carouselJson)){
        carousels = carouselService.findAll(CommonFlagEnums.YES.getCode());
        // 写入Redis缓存
        redisUtils.set("carousel", JSONObject.toJSONString(carousels, SerializerFeature.PrettyFormat));
    }else {
        carousels = JSONObject.parseArray(carouselJson,Carousel.class);
    }
    return ResponseResult.ok(carousels);
}

@ApiOperation("获取所有的商品大类")
@GetMapping("/cats")
public ResponseResult cats(){
    String catsJson = redisUtils.get("cats");
    List<Category> categories=null;
    if(StringUtils.isBlank(catsJson)){
        categories = categoryService.findRootLevelCats();
        redisUtils.set("cats",JSONObject.toJSONString(categories,SerializerFeature.PrettyFormat));
    }else {
        categories = JSONObject.parseArray(catsJson,Category.class);
    }
    return ResponseResult.ok(categories);
}

@ApiOperation("获取商品大类子类")
@GetMapping("/subCat/{rootId}")
public ResponseResult cats(@PathVariable(name="rootId") Integer rootId){
    if(rootId==null) {
        return ResponseResult.errorMsg("分类异常");
    }
    String subCat = redisUtils.hget("subCat",String.valueOf(rootId));
    List<CategoryVo> categoryVos=null;
    if(StringUtils.isBlank(subCat)){
        categoryVos = categoryService.getSubCatList(rootId);
        redisUtils.hset("subCat",String.valueOf(rootId),JSONObject.toJSONString(categoryVos,SerializerFeature.PrettyFormat));
    }else{
        categoryVos = JSONObject.parseArray(subCat,CategoryVo.class);
    }
    return ResponseResult.ok(categoryVos);
}
```



### 3.2 优化购物车

1. <font color=red>用户登录之后,添加和删除购物车,分别也会添加删除redis中的缓存数据</font>
2. <font color=red>用户注册/登录之后,将Cookie中的数据同步过去</font>
   - redis中有数据
     - cookie中购物车中有数据,将cookie数据数据合并到redis中
     - cookie中没有数据,将redis数据合并到cookie中
   - redis中没有数据
     - cookie中购物车中有数据,直接将cookie数据放入redis
     - cookie中没有数据,什么也不做
3. <font color=red>用户创建订单后,更新redis中购物车的数据</font>

<font color=red color=red>**①. 优化 添加删除购物车 ->ShopCartController**</font>

```java
@Slf4j
@Api(tags = "购物车")
@RestController
@RequestMapping("/shopcart")
public class ShopCartController {

    @Autowired
    private RedisUtils redisUtils;


    /**
     * 未登录 -> 登录 / 已登录 => 将商品的数据存入Redis
     * @param userId 用户Id
     * @param shopcartBo 购物车数据
     * @param request
     * @param response
     * @return
     */
    @ApiOperation("添加购物车")
    @PostMapping("/add")
    public ResponseResult add(@RequestParam(value = "userId") String userId,
                              @RequestBody ShopcartBo shopcartBo,
                              HttpServletRequest request,
                              HttpServletResponse response){
        if(StringUtils.isBlank(userId)){
            return ResponseResult.errorMsg("");
        }
        // 用户在登录的情况下, 添加商品到购物车,而且同时将数据同步到redis缓存中
        // 如果是同一件商品,则需要对数量进行累加
        List<ShopcartBo> shopcartList = new ArrayList<>();
        String currentCart = redisUtils.hget(CommonConstant.COOKIE_SHOP_CART, userId);
        if(StringUtils.isBlank(currentCart)){
            shopcartList.add(shopcartBo);
        }else{
            List<ShopcartBo> list = JSONObject.parseArray(currentCart, ShopcartBo.class);
            boolean isExists=false;
            for (ShopcartBo bo : list) {
                if(bo.getSpecId().equals(shopcartBo.getSpecId())){
                    bo.setBuyCounts(bo.getBuyCounts()+shopcartBo.getBuyCounts());
                    isExists=true;
                }
            }
            shopcartList.addAll(list);
            if(!isExists){
                shopcartList.add(shopcartBo);
            }
        }
        redisUtils.hset(CommonConstant.COOKIE_SHOP_CART, userId,JSONObject.toJSONString(shopcartList, SerializerFeature.PrettyFormat));
        return ResponseResult.ok();
    }

    /**
     * 未登录 -> 登录 / 已登录 => 删除Redis中的指定商品数据
     * @param userId 用户Id
     * @param itemSpecId  商品规格Id
     * @param request
     * @param response
     * @return
     */
    @ApiOperation("删除购物车中数据")
    @PostMapping("/del")
    public ResponseResult add(@RequestParam(value = "userId") String userId,
                              @RequestParam(value = "itemSpecId",required = false) String itemSpecId,
                              HttpServletRequest request,
                              HttpServletResponse response){
        if(StringUtils.isBlank(userId) || StringUtils.isBlank(itemSpecId)){
            return ResponseResult.errorMsg("");
        }
        // 用户删除购物车中的数据,同步删除redis中的数据
        String currentCart = redisUtils.hget(CommonConstant.COOKIE_SHOP_CART, userId);
        List<ShopcartBo> shopcartList = new ArrayList<>();
        List<ShopcartBo> list = JSONObject.parseArray(currentCart, ShopcartBo.class);
        for (ShopcartBo bo : list) {
            if(!bo.getSpecId().equalsIgnoreCase(itemSpecId)){
                shopcartList.add(bo);
            }
        }
        if(CollectionUtils.isEmpty(shopcartList)){
            redisUtils.hdel(CommonConstant.COOKIE_SHOP_CART,userId);
        }else{
            redisUtils.hset(CommonConstant.COOKIE_SHOP_CART,userId,JSONObject.toJSONString(shopcartList, SerializerFeature.PrettyFormat));
        }
        return ResponseResult.ok();
    }
}
```

<font color=red color=red>**②. 优化 创建订单时,更新购物车信息 ->OrdersController**</font>

```java
@ApiOperation("创建订单")
@PostMapping("/create")
public ResponseResult createOrders(@RequestBody SubmitOrderBo submitOrderBo,
                                   HttpServletRequest request,
                                   HttpServletResponse response){
    if(!submitOrderBo.getPayMethod().equals(PayMethodEnums.ALIPAY) ||
       !submitOrderBo.getPayMethod().equals(PayMethodEnums.WECHAT)){
        ResponseResult.errorMsg("不支持的支付方式!");
    }
    // 1. 创建订单
    String hget = redisUtils.hget(CommonConstant.COOKIE_SHOP_CART, submitOrderBo.getUserId());
    List<ShopcartBo> shopcartBoList = JSONObject.parseArray(hget, ShopcartBo.class);
    OrderVo orderVo = orderService.createOrder(shopcartBoList,submitOrderBo);

    // 2. 创建订单后,移除购物车中已经提交结算的数据
    // 删除redis里购物车中的数据,并且同步前端的Cookie
    redisUtils.hset(CommonConstant.COOKIE_SHOP_CART, submitOrderBo.getUserId(),JSONObject.toJSONString(orderVo.getToConver(), SerializerFeature.PrettyFormat));
    CookieUtils.setCookie(request,response, CommonConstant.COOKIE_SHOP_CART,JSONObject.toJSONString(orderVo.getToConver(), SerializerFeature.PrettyFormat),true);

    // 3. 向支付中心发送当前订单,用于保存支付中心的订单数据
    MerchantOrdersVo merchantOrdersVo = orderVo.getMerchantOrdersVo();
    // 通过RestTemplate 发送请求
    HttpHeaders httpHeaders = new HttpHeaders();
    httpHeaders.setContentType(MediaType.APPLICATION_JSON);
    httpHeaders.add("imoocUserId","imooc");
    httpHeaders.add("password","imooc");
    HttpEntity<MerchantOrdersVo> entity = new HttpEntity<>(merchantOrdersVo,httpHeaders);

    ResponseEntity<ResponseResult> responseEntity = restTemplate.postForEntity(CommonConstant.PAYMENT_URL, entity, ResponseResult.class);
    ResponseResult paymentResult = responseEntity.getBody();
    if(!paymentResult.getStatus().equals(ResponseResult.SUCCESS)){
        return ResponseResult.errorMsg("订单创建失败");
    }

    return ResponseResult.ok(orderVo.getOrderId());
}
```

<font color=red color=red>**③. 优化 注册/登录时,同步数据 ->OrdersController**</font>

```java
private void synData(String userId,HttpServletResponse resp, HttpServletRequest req){
    // 获取redis中用户购物车
    String redisCart = redisUtils.hget(CommonConstant.COOKIE_SHOP_CART, userId);
    // 获取cookie中用户购物车
    String cookieCart = CookieUtils.getCookieValue(req,CommonConstant.COOKIE_SHOP_CART,true);
    if(StringUtils.isBlank(redisCart)){
        if(StringUtils.isNotBlank(cookieCart)){
            //redis x  cookie √ ->cookie to redis
            redisUtils.hset(CommonConstant.COOKIE_SHOP_CART, userId,cookieCart);
        }
    }else{
        if(StringUtils.isBlank(cookieCart)){
            //redis √  cookie x ->redis to cookie
            CookieUtils.setCookie(req,resp,CommonConstant.COOKIE_SHOP_CART,redisCart,true);
        }else{
            //redis √  cookie √ ->redis merge cookie
            // 所有已经存在的商品
            List<ShopcartBo> shopcartExistsList = new ArrayList<>();
            List<ShopcartBo> redisList = JSONObject.parseArray(redisCart,ShopcartBo.class);
            List<ShopcartBo> cookieList = JSONObject.parseArray(cookieCart,ShopcartBo.class);
            for (ShopcartBo redisItem : redisList) {
                for (ShopcartBo cookieItem : cookieList) {
                    if(cookieItem.getSpecId().equals(redisItem.getSpecId())){
                        redisItem.setBuyCounts(cookieItem.getBuyCounts()+redisItem.getBuyCounts());
                        shopcartExistsList.add(redisItem);
                        break;
                    }
                }
            }
            // 所有的商品
            List<ShopcartBo> total = new ArrayList<>();
            total.addAll(redisList);
            total.addAll(cookieList);
            List<ShopcartBo> finalList = new ArrayList<>();
            if(CollectionUtils.isEmpty(shopcartExistsList)){
                finalList = total;
            }else{
                // 循环删除重复的数据
                for (ShopcartBo exists : shopcartExistsList) {
                    total.removeIf(x->x.getSpecId().equals(exists.getSpecId()));
                }
                finalList.addAll(total);
                finalList.addAll(shopcartExistsList);
            }

            redisUtils.hset(CommonConstant.COOKIE_SHOP_CART, userId,JSONObject.toJSONString(finalList, SerializerFeature.PrettyFormat));
            CookieUtils.setCookie(req,resp,CommonConstant.COOKIE_SHOP_CART,JSONObject.toJSONString(finalList, SerializerFeature.PrettyFormat),true);
        }
    }
}
```





































































