[TOC]

### 1. 缓存穿透

- <font color=red>**什么是缓存穿透?**</font>
  - <font color=blue>用户恶意模拟请求很多**缓存和数据库中都不存在的数据**,导致用户的请求短时间内直接落在数据库上。</font>
- <font color=red>**缓存穿透的解决方案?**</font>
  1. **如果用户的数据在数据库中没有,查询完数据库后,将空数据也同样的缓存写入到Redis中**
  2. **缓存预热**
  3. <font color=red>**布隆过滤器**</font> => 在Redis之前的一层拦截

#### 1.1 布隆过滤器

- <font color=red>布隆过滤器的本质是一个**二进制数组** => 0:表示数据不存在  1:表示数据存在</font>
  - 通过hash的方式将得到一个值并且对应到过滤器数组的"桶位"
  - <font color=green>当然,不同数据经过hash算法是计算后得到的 桶位置可能相同,这种情况就是**哈希冲突/哈希碰撞**</font>
- <font color=red>布隆过滤器一般用于快速判某个元素是否存在于集合中</font>
  - ==其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回==
    - 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱
    - Google Chrome 使用布隆过滤器识别恶意 URL
    - 网页爬虫对URL去重，避免爬取相同的 URL 地址
    - ....
- <font color=red>布隆过滤器的关键就在于hash算法和容器大小</font> 
  - ==容器越大, 过滤器的误判率就会越低!!==
- <font color=red>布隆过滤器的缺点?</font>
  - <font color=blue>**布隆过滤器的数据是无法被移除的,这个导致如果Redis和数据库中的数据被移除后,无法更新布隆过滤器中的数据**</font>
  - <font color=blue>**代码复杂度较高**</font>
  - <font color=blue>**布隆过滤器存在一定的误判率**</font>

##### 1.1.1 布隆过滤器说明

- 如图所示
  1. 集合中a,b,c三个元素经过hash后会散列到得到某个位置(图中每个元素测试了三次)
  2. 判断a,b,c三个元素时,通过hash计算,<font color=red>一定会在布隆过滤器中找到对应的桶位</font>
  3. 但是对于某个不存在的元素 d,e,通过hash计算后,可能与a,b,c 元素所在桶相同,<font color=red>这样就是一种误判</font>
- <font color=red>**说明**</font>
  1. <font color=red>如果元素一定存在,那么布隆过滤器判断也一定存在</font>
  2. <font color=red>如果元素不存在,那么布隆过滤器可能会判断存在->误判</font>

![image-20201006142259946](image/4.%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/image-20201006142259946.png)

#### 1.2 使用布隆过滤器

- 可以使用 谷歌提供的工具类`Guava` 进行实现
- **操作步骤**
  1. 引入Guava的依赖包
  2. 通过 <font color=red> `BloomFilter#create(Funnel<? super T> contentCharset, long expectedInsertions, double fpp)`</font >
     - `contentCharset` => 布隆过滤器中内容的编码
     - `expectedInsertions` => 布隆过滤器的字节数组的大小
     - `fpp` => 误判率
  3. 通过 `bloomFilter.put(key)` 插入数据
  4. 通过 `bloomFilter.mighrContain(key)` 判断数据是不是**可能存在**

**测试布隆过滤器**

- 通过测试可以看到 : <font color=red>设定通过设定容器大小以及误判率,可以减小误判的数量</font>

```java
public class BloomFilterTest {

    @Test
    public void testBloomFilter(){

        // 创建一个能存入10000 的布隆过滤器
        BloomFilter<CharSequence> bf1 = BloomFilter.create(Funnels.stringFunnel(Charset.forName("utf-8")), 10000);

        // 创建一个能存入100000 的布隆过滤器
        BloomFilter<CharSequence> bf2 = BloomFilter.create(Funnels.stringFunnel(Charset.forName("utf-8")), 100000);

        // 创建一个能存入100000 的布隆过滤器,同时指定误判率 0.0001
        BloomFilter<CharSequence> bf3 = BloomFilter.create(Funnels.stringFunnel(Charset.forName("utf-8")), 100000,0.0001);

        for (int i = 0; i < 100000; i++) {
            bf1.put(String.valueOf(i));
            bf2.put(String.valueOf(i));
            bf3.put(String.valueOf(i));
        }

        int count1=0;
        int count2=0;
        int count3=0;
        for (int i = 0; i < 10000; i++) {
            boolean b1 = bf1.mightContain("test:" + i);
            boolean b2 = bf2.mightContain("test:" + i);
            boolean b3 = bf3.mightContain("test:" + i);
            if(b1){
                count1++;
            }
            if(b2){
                count2++;
            }
            if(b3){
                count3++;
            }
        }
        System.out.println("设定容量10000的布隆过滤器,误判=>"+count1);      // 设定容量10000的布隆过滤器,误判=>9949
        System.out.println("设定容量100000的布隆过滤器,误判=>"+count2);     // 设定容量100000的布隆过滤器,误判=>285
        System.out.println("设定容量100000的布隆过滤器,指定误判率为0.0001,误判=>"+count3); // 设定容量100000的布隆过滤器,指定误判率为0.0001,误判=>1

    }
}
```



### 2.缓存雪崩

- <font color=red>**什么是缓存雪崩?**</font>
  - <font color=blue>缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常</font>
- <font color=red>**缓存雪崩如何预防?**</font>
  1. 设置Key永不过期
  2. key 过期时间错开 -> 保证所有的key不是统一失效
     - ==一些热点的数据可以设置较长的有效期==
  3. 多缓存结合 -> 比如Redis + Memcache

### 3. 批量查询的优化

- <font color=red>**和数据库连接一样,建立与Redis Server 的连接是一个很耗时的操作,所以一次查询可以查多个,就不要多次查询**</font>
  - ==或者使用 Redis连接池,比如**Redisson**==

#### 3.1 multiGet 批量查询优化

- 如果有大批量的数据需要查询,可以使用 redis 的批量查询的命令

```java
@Autowired
private StringRedisTemplate stringRedisTemplate;
public List<String> mget(List<String> keys){
    return stringRedisTemplate.opsForValue().multiGet(keys);
}
```

#### 3.2 pipeline的批量查询

- 使用RestTemplate的 `executePipelined`的方法尽进行pipeline的批量查询
- <font color=red>Redis客户端与Redis的Server 之间建立一个管道(pipeline),所有的命令在这个管道中进行,省去建立连接的耗时!</font>
- **相对于 multiGet 的方式,pipeline的批量查询能支持更多的操作,而不是简单的只有get获取数据**

```java
public List<Object> batchGet(List<String> keys){
    List<Object> result = stringRedisTemplate.executePipelined(new RedisCallback<String>() {
        @Override
        public String doInRedis(RedisConnection connection) throws DataAccessException {
            StringRedisConnection con = (StringRedisConnection) connection;
            for (String key : keys) {
                con.get(key);
            }
            return null;
        }
    });
    return result;
}
```

### 4. Redis总结

1. 分布式和集群 -> 不同的节点做着不同的事，就是分布式，不同的节点做着相同的事就是集群

2. Redis功能强劲，可以作为缓存写入内存，提供高速访问，为数据库做了一道屏障，保护数据库，把热点数据放入缓存，从而提升项目的并发量与吞吐量

3. Redis是单线程的，但是他的性能却很高，主要是因为它的Redis的单线程模型 -> 多路复用器

4. Redis的持久化机制，RDB与AOF，一个是全量备份，一个是增量定时

5. 单机Redis存在单点故障与读并发量的限制，所以可以通过主从与哨兵来实现，主从解决读写分离，并且一主多从能够提升读的并发

6. 哨兵提供监控机制，一旦主挂了，备则上位成为主，如此实现高可用

7. 在Redis中可以设置无磁盘化，如果磁盘比较慢，可以打开

8. 当key过期了，你会发现内存占用率还是很高，这是因为redis的机制，有被动主动之分

9. 对于内存写满后的key淘汰机制，有不同的策略可以配置

10. Redis除了单机与哨兵模式外，还能搭建集群，最经典的还属三主三从
11. 对于缓存来说，我们还需要预防缓存穿透与雪崩
    - ==穿透的话一般来说只需要针对空值缓存就行，过期时间设置5-10分钟，这样就流量就不会打在数据库上导致死机宕机==
    - ==雪崩其实也可以做到提前预防，那就是用到过期时间的key，时间全部错开==
      - 此外，有些数据可以做永久保存的话那就直接保存好了，这样就不会造成大面积的key失效了
12. 当一次请求过来，如果查询的key比较多，能做到批量就批量，如果是循环查询缓存的话，吞吐量低

### 5. Redis 面试常问点

```txt
1.什么是 Redis?

2.Redis 的数据类型？

3.使用 Redis 有哪些好处？

4.Redis 相比 Memcached 有哪些优势？

5.Memcached 与 Redis 的区别都有哪些？

6.Redis 是单进程单线程的吗？为何它那么快那么高效？

7.一个字符串类型的值能存储最大容量是多少？

8.Redis 的持久化机制是什么？各自的优缺点？

9.Redis 常见性能问题和解决方案有哪些?

10.Redis 过期键的删除策略？

11.Redis 的回收策略（淘汰策略）?

12.为什么Redis 需要把所有数据放到内存中？

13.Redis 的同步机制了解么？

14.Pipeline 有什么好处，为什么要用 Pipeline？

15.是否使用过 Redis 集群，集群的原理是什么？

16.Redis 集群方案什么情况下会导致整个集群不可用？

17.Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

18.Jedis 与 Redisson 对比有什么优缺点？

19.Redis 如何设置密码及验证密码？

20.说说 Redis 哈希槽的概念？

21.Redis 集群的主从复制模型是怎样的？

22.Redis 集群会有写操作丢失吗？为什么？

23.Redis 集群之间是如何复制的？

24.Redis 集群最大节点个数是多少？

25.Redis 集群如何选择数据库？

26.怎么测试 Redis 的连通性？

27.怎么理解 Redis 事务？

28.Redis 事务相关的命令有哪几个？

29.Redis key 的过期时间和永久有效分别怎么设置？

30.Redis 如何做内存优化？

31.Redis 回收进程如何工作的？

32.都有哪些办法可以降低 Redis 的内存使用情况呢？

33.Redis 的内存用完了会发生什么？

34.一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？

35.MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？

36.Redis 最适合的场景是什么？

37.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

38.如果有大量的 key 需要设置同一时间过期，一般需要注意什么？

39.使用过 Redis 做异步队列么，你是怎么用的？

40.使用过 Redis 分布式锁么，它是什么回事？

41.如何预防缓存穿透与雪崩
```







